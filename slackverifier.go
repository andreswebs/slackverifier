// Package slackverifier provides functionality to verify incoming Slack webhook requests
// by validating their signatures against a signing secret.
package slackverifier

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"strconv"
	"time"
)

const (
	// SlackSignatureHeader is the HTTP header name containing the Slack signature.
	// This header contains the request signature used to verify the authenticity
	// of incoming webhook requests from Slack.
	SlackSignatureHeader string = "X-Slack-Signature"

	// SlackTimestampHeader is the HTTP header name containing the request timestamp.
	// This timestamp is used in conjunction with the signature to prevent replay attacks
	// by ensuring the request was made within an acceptable time window.
	SlackTimestampHeader string = "X-Slack-Request-Timestamp"
)

var (
	// ErrInvalidSignature is returned when the computed signature does not match
	// the signature provided in the Slack request header.
	ErrInvalidSignature = errors.New("invalid signature")

	// ErrMaxAllowedRequestAgeExceeded is returned when the request timestamp
	// is older than the configured MaxAllowedRequestAge duration.
	ErrMaxAllowedRequestAgeExceeded = errors.New("max allowed request age exceeded")
)

// SlackRequestData contains all necessary information to verify a Slack webhook request.
type SlackRequestData struct {
	// Version is the signature version used by Slack (defaults to "v0")
	Version string
	// RawBody is the raw request body bytes from the webhook
	RawBody []byte
	// SlackSignature is the signature provided in the X-Slack-Signature header
	SlackSignature string
	// Timestamp is the request timestamp from X-Slack-Request-Timestamp header
	Timestamp string
	// SigningSecret is the Slack application's signing secret
	SigningSecret string
	// MaxAllowedRequestAge specifies the maximum time window during which a request is considered valid
	MaxAllowedRequestAge time.Duration
}

// Verify checks if the request is authentic by comparing the provided signature
// with a computed signature using the signing secret. It returns true if the
// signatures match, indicating the request is valid and came from Slack.
//
// The signature is computed using HMAC SHA256 with the following format:
// v0=<hex(HMAC-SHA256(signing_secret, v0:timestamp:body))>
func (s SlackRequestData) VerifySignature() (ok bool, err error) {
	sig, err := GenerateSignature(s.Version, s.Timestamp, s.RawBody, s.SigningSecret)
	if err != nil {
		return
	}

	ok = hmac.Equal([]byte(sig), []byte(s.SlackSignature))
	if !ok {
		err = ErrInvalidSignature
		return
	}

	return
}

// VerifyTimestamp checks if the request's timestamp is within the allowed time window.
// It returns true if the request is not too old, and false with an error if the request
// has exceeded the MaxAllowedRequestAge. If MaxAllowedRequestAge is not set, it defaults
// to 60 seconds.
//
// This check helps prevent replay attacks by ensuring requests are recent enough to be valid.
func (s SlackRequestData) VerifyTimestamp() (ok bool, err error) {
	if s.MaxAllowedRequestAge == 0 {
		s.MaxAllowedRequestAge = 60 * time.Second
	}

	intTs, err := s.IntTimestamp()
	if err != nil {
		return
	}

	now := time.Now()

	if now.After(time.Unix(intTs, 0).Add(s.MaxAllowedRequestAge)) {
		return false, ErrMaxAllowedRequestAgeExceeded
	}

	return true, nil
}

// IntTimestamp converts the request's timestamp string to an int64 Unix timestamp.
// Returns an error if the timestamp string cannot be parsed as a base-10 integer.
func (s SlackRequestData) IntTimestamp() (ts int64, err error) {
	ts, err = strconv.ParseInt(s.Timestamp, 10, 64)
	return
}

// GenerateSignature creates a Slack-compatible request signature using HMAC SHA256.
// The signature is generated by concatenating version:timestamp:body and using the
// signing secret as the HMAC key.
//
// Parameters:
//   - version: Slack signature version (defaults to "v0" if empty)
//   - timestamp: Unix timestamp of the request
//   - data: Raw request body bytes
//   - secret: Slack signing secret used as HMAC key
//
// Returns:
//   - sig: Generated signature in format "v0=<hex(HMAC-SHA256(secret, message))>"
//   - err: Error if HMAC operation fails
func GenerateSignature(version string, timestamp string, data []byte, secret string) (sig string, err error) {
	if version == "" {
		version = "v0"
	}
	message := fmt.Sprintf("%v:%v:%v", version, timestamp, string(data))
	hash := hmac.New(sha256.New, []byte(secret))
	_, err = hash.Write([]byte(message))
	if err != nil {
		return
	}
	sig = fmt.Sprintf("%v=%v", version, string(hex.EncodeToString(hash.Sum(nil))))
	return
}

// SlackVerificationMiddleware creates an http.Handler that verifies incoming Slack webhook requests.
// It checks the request signature and timestamp to ensure the request is authentic and recent.
//
// The middleware performs the following checks:
// - Validates presence of required Slack headers (X-Slack-Signature and X-Slack-Request-Timestamp)
// - Ensures the request uses POST method
// - Verifies the request signature against the signing secret
// - Checks if the request timestamp is within the allowed time window
//
// If any check fails, the middleware responds with an appropriate HTTP status code:
// - 400 Bad Request: missing headers or invalid request body
// - 405 Method Not Allowed: non-POST requests
// - 401 Unauthorized: invalid signature or expired timestamp
//
// Parameters:
//   - secret: The Slack signing secret used to verify request signatures
//   - next: The handler to call if all verification checks pass
//
// Returns an http.Handler that wraps the provided handler with Slack verification.
func SlackVerificationMiddleware(secret string, next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		sig := r.Header.Get(SlackSignatureHeader)
		ts := r.Header.Get(SlackTimestampHeader)

		if sig == "" {
			slog.Error(fmt.Sprintf("header %s is empty", SlackSignatureHeader))
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		if ts == "" {
			slog.Error(fmt.Sprintf("header %s is empty", SlackTimestampHeader))
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		if r.Method != http.MethodPost {
			slog.Error(fmt.Sprintf("invalid HTTP method: %s", r.Method))
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}

		buf, err := io.ReadAll(r.Body)
		if err != nil {
			slog.Error("failed to read request body", slog.Any("err", err))
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		data := SlackRequestData{
			RawBody:        buf,
			SlackSignature: sig,
			Timestamp:      ts,
			SigningSecret:  secret,
		}

		if ok, err := data.VerifySignature(); !ok {
			if err != nil {
				slog.Error("failed signature verification", slog.Any("err", err))
			}
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		if ok, err := data.VerifyTimestamp(); !ok {
			if err != nil {
				slog.Error("failed timestamp verification", slog.Any("err", err))
			}
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		next.ServeHTTP(w, r)
	})
}
